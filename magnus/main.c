/**############################################################################
 ** TITLE:		CipherSearch
 ** AUTHOR:		Magnus Overbo
 ** ABOUT:		Ciphersearch utilise the GMP library to manage arbitrary sized
 **						numbers and perform an unconstrained approximate row-based bit
 **						parallell search.  It searches for an intercepted bitsequence,
 **						generated by a dessimated LFSR encrypted with a message, and
 **						tries to find this in all possible generated states which is
 **						not dessimated.
 **
 ** Release:	20190313 - 64b version
 ** Release:	20190328 - GMP library version for arbitrary bit size
 **#########################################################################**/

//-----------------------------------------------------------------------------
// INCLUDES
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>     //strlen
#include <stdint.h>     //64b Int
#include <inttypes.h>   //64b int
#include <gmp.h>        //arbitrary integer size

//-----------------------------------------------------------------------------
// GLOBAL VARIABLES
//-----------------------------------------------------------------------------
char* FNAME;		//Output filename
const int ALPHASIZE = 2;//Alphabet size, 0 & 1
int m = 896; 		//Size of search word
int n = 1738;		//Size of text
int slen = 448;		//K value
int deg	= 11;		//Polynomial degree
int SSTATE = 32;
int CSTATE = 1;
mpz_t PLAINTEXT;	//Message to encipher
mpz_t TEXT;		//Search text


//-----------------------------------------------------------------------------
// LFSR STRUCT
//-----------------------------------------------------------------------------
struct LFSR {
	mpz_t POLYNOMIAL; //Polynomial definition
	mpz_t STATE;	  //LFSR state
	int DEGREE;	  //Polynomial degree
};


//-----------------------------------------------------------------------------
// FUNCTION DECLARATIONs
//-----------------------------------------------------------------------------
mpz_t* genAlphabet( int );					   //Gen array of the alphabet
int lfsr_iterate( struct LFSR*);				   //Gen next state & output
void lfsrgen(mpz_t, int, int, mpz_t, uint_least64_t, int, mpz_t*); //Gen LFRS
mpz_t* arbp_search( mpz_t*, int );                                 //Main search function
mpz_t* genError(int);  						   //Gen init error table
void genPrefixes( mpz_t*, mpz_t );				   //Generate the prefixes
void genEncrypt( mpz_t, mpz_t, mpz_t );	                           //Encrypt the plaintext
void mpz_lshift( mpz_t, int );					   //Left shift bin seq by 1
char* pb( mpz_t, int );						   //Print prepending zeros

//-----------------------------------------------------------------------------
//	MAIN FUNCTION
//-----------------------------------------------------------------------------
int main(int argc, char *argv[]){
	if( argc != 5 ){	      				//Check required input parameters
		printf("Too few arguments\n");
		return 0;
	}

	deg = atoi( argv[1] );										//Polynomial degree
	m		= atoi( argv[2] );										//Search word length
	slen= atoi( argv[3] ) + 1 ;								//Allowed errors
	n		= 2*m;																//Serach text length 2m

	printf("0: %s\n", argv[0]);								//Debug
	printf("L:\t%d\n", deg);
	printf("M:\t%d\n", m);
	printf("N:\t%d\n", n);
	printf("K:\t%d + 1\n", slen-1);

	FNAME = malloc(60*sizeof(char));					//Filename allocation
	sprintf(FNAME, "cipherserach_L%dM%dK%d_%s.log", deg, m, slen-1, argv[4]);

	mpz_t	max;		mpz_init(	max );
	mpz_setbit(max, deg);											//Set max val, eg 2048 in 2^11

	mpz_t pol;		mpz_init( pol );
	if( deg == 11 ){													//Set polynomial based on degree
		mpz_set_ui(pol, 1209);									//2^11 irreducible polynomial
		printf( "POL: 1209\n" );
	}
	else if( deg == 16 ){								
		mpz_set_ui(pol, 33262);									//2^16 irreducible polynomial
		printf( "POL: 33262\n" );
	}
	else{
		printf("Invaldig polynomial degree\n");
		return 0;
	}

	printf("START:\t%s\n", argv[4]);							//Debug

	mpz_init(PLAINTEXT);
	mpz_set_ui(PLAINTEXT, 0);											//Default value is 0

	printf("START\n");
	mpz_t*	B	= genAlphabet( ALPHASIZE );					//Generate alphabet

	mpz_t LCLK;		mpz_init(LCLK);									//LFSR for dessimating
	lfsrgen(LCLK, deg, m, pol,  300, 0, NULL);		//Clocking LFSR
	mpz_t LDES;		mpz_init(LDES);									//LFSR to be dessimated
	lfsrgen(LDES, deg, n, pol, SSTATE, 0, NULL);	//Dessimated LFSR

	mpz_t CIPHER;		mpz_init( CIPHER );						//Gen intercepted ciphertext
	genEncrypt(	CIPHER, LCLK, LDES );

	genPrefixes( B, CIPHER);											//Gen prefixes for the alphabet

	char* t = pb(pol,deg);
	//Output generated data
	#if defined DEBUG
	printf( "Setup:" );
	printf( "\n\tPOLY:\t\t%s", t);		mpz_out_str(stdout, 2, pol);
	free(t);	t = pb(PLAINTEXT, m);
	printf( "\n\tPLAINTEXT:\t%s", t);	mpz_out_str(stdout, 2, PLAINTEXT);
	free(t);	t = pb(LCLK, m);
	printf( "\n\tLFSR CLK:\t%s", t);	mpz_out_str(stdout, 2, LCLK);
	free(t);	t = pb(LDES, n);
	printf( "\n\tLFSR DES:\t%s", t);	mpz_out_str(stdout, 2, LDES);
	free(t);	t = pb(CIPHER,m);
	printf( "\n\tCIPHER:\t\t%s", t);	mpz_out_str(stdout, 2, CIPHER);
	free(t);	t = pb(B[0], m);
	printf( "\nAlphabet:\tB[0]:\t%s", t); mpz_out_str(stdout, 2, B[0]);
	free(t);	t = pb(B[1], m);
	printf( "\n\t\tB[1]:\t%s", t);	mpz_out_str(stdout, 2, B[1]);
	free(t);
	printf( "\n\n" );
	#endif

	mpz_clear( LCLK );													//Cleanup LFSRs
	mpz_clear( LDES );

	mpz_t tmp;		mpz_init( tmp );							//Geneate tmp variable
	
	uint_least64_t i = 1;												//initial state counter.
	FILE*					fh = fopen(FNAME, "w");				//Open output file for writing

	//While i less than 2^deg
	while( mpz_cmp_ui( max, i ) > 0 ){
		CSTATE = i;
		mpz_set_ui( tmp, i);											//For binary display
		t = pb(tmp, deg);
		#if defined DEBUG
		printf("\nINITIAL STATE\t%"PRIu64"\t%s", i, t);
		mpz_out_str( stdout, 2, tmp);		printf("\n");
		#endif

		lfsrgen( TEXT, deg, n, pol, i, 1, B );		//Undessimated bitseq iv=i
		#if defined DEBUG
		free(t);	t = pb(TEXT,n);
		printf( "TEXT:\t\t%s", t );		mpz_out_str(stdout, 2, TEXT);
		free(t);	t = pb(CIPHER,m);
		printf( "\nCIPHER:\t\t%s", t); mpz_out_str(stdout, 2, CIPHER);
		printf( "\n" );
		#endif

		#if defined DEBUG
		printf( "Perform ARBP search\n" );
		#endif
		mpz_t*	MATCH = arbp_search(B, slen);

		free(t);	t = pb(tmp, deg);
		//Print initial state and all matches to screen and file
		#if defined DEBUG
		printf( "INITSTATE\t%"PRIu64"\n", i);
		printf("\nMATCH\t" );
		fprintf( fh, "INITSTATE\t%"PRIu64"\t%s", i, t );
		mpz_out_str(fh, 2, tmp);
		fprintf( fh, "\nMATCH\t" );
		#else
		if( CSTATE == SSTATE ){
			printf( "INITSTATE\t%"PRIu64"\n", i);
			fprintf( fh, "INITSTATE\t%"PRIu64"\t%s", i, t );
			mpz_out_str(fh, 2, tmp);
			fprintf( fh, "\nMATCH\t" );
		}
		#endif
		free( t );

		#if !defined DEBUG
		if( CSTATE == SSTATE ){
		#endif
			int j			= 0;
			int k			= 0;
			while( j<n ){																//For each position
				if( mpz_cmp_ui(MATCH[j], m) < 0){					//If match is less than m
					if( k > 0 && (k%15)==0 ){								//Decoration of stdout
						printf("\n\t");
					}
					printf( "\t%d:", j); mpz_out_str(stdout, 10, MATCH[j] );
					fprintf( fh, " %d:", j);	mpz_out_str( fh, 10, MATCH[j] );
					mpz_clear( MATCH[j] );
					k++;																		//increment counter for print
				}
				j++;																			//Next position
			}
			fprintf( fh, "\n");
			printf( "\n\n" );
			fprintf( fh, "\n" );
			fflush( fh );
		#if !defined DEBUG
		}
		#endif
		i++;																					//Next initial state
		free(MATCH);
	}
	mpz_clear( TEXT );															//Clear variables
	mpz_clear( PLAINTEXT );
	mpz_clear( CIPHER );
	mpz_clear( B[0] );
	mpz_clear( B[1] );
	free( B );																			//Free up memory
	fclose( fh );																		//Close data file
	printf("\n\nSoftware done\n");
	return 0;
}



/**############################################################################
 **
 **	FUNCTIONS
 **
 **#########################################################################**/
/*-----------------------------------------------------------------------------
 * Prepend zeros to a binary representation of a number.
 *	returns a char pointer to an array filled with missing zeros or nothing
 *	if it is already full.
-----------------------------------------------------------------------------*/
char* pb( mpz_t num, int len ){
	size_t plen = len+1 - mpz_sizeinbase( num, 2 );
	if( plen == 0 )
		return "";
	char* pre = malloc( plen * sizeof(char) );			//Allocate plen length array
	int i = 0;
	while( i < plen-1 ){
		pre[i++] = '0';
	}
	pre[i]='\0';
	return pre;
}

/*-----------------------------------------------------------------------------
 *	Left shift MPZ_T variable to the left
 *		n number of shift
 *		rop is mpz_t value to shift
-----------------------------------------------------------------------------*/
void mpz_lshift( mpz_t rop, int len ) {
	mpz_t	tmp;	mpz_init( tmp );							//temp variable
	int i		= len-1;
	while( i > 0 ){
		if(mpz_tstbit(rop, i-1) == 1){
			mpz_setbit( tmp, i );									//set bit if it
		}
		i--;
	}
	mpz_set(rop, tmp);												//Set original var to tmp
	mpz_clear(tmp);
}

/*-----------------------------------------------------------------------------
 * Generates the cipher which then becomes the prefix.
 *	Y is the clocking LFSR
 *	X is the encrypting LFSR
-----------------------------------------------------------------------------*/
void genEncrypt(mpz_t rop, mpz_t CLK, mpz_t DES){
	int 	i				=	0;		int 	j				= 0;
	int 	x, y;
	mpz_t CIPHER;		mpz_init(CIPHER);

	while( i < m ){										//Counter for clocking lfsr
		x = 0;		y = 0;
		#if defined DEBUG
		printf("CLK(%d)=%d	", i, mpz_tstbit(CLK, i) );
		#endif

		if( mpz_tstbit(CLK, i) == 1 ){
				j++;												//Decimate LFSR by skipping a bit
				#if defined DEBUG
				printf("\tDES(%d)=%d --> \tDES(%d)=%d", j-1,
								mpz_tstbit(DES, j-1), j, mpz_tstbit(DES, j) );
				#endif
		}
		#if defined DEBUG
		else{
			printf("\t\t\tDES(%d)=%d", j, mpz_tstbit(DES,j));
		}
		#endif

		//Val of dessimated LFSR output
		if( mpz_tstbit(DES, j) == 1 )					x = 1;	//grab value of bit
		if( mpz_tstbit(PLAINTEXT, i) == 1 )		y = 1;	//Grab value of bit
		if( (y^x) == 1 )	mpz_setbit(CIPHER, i);			//Xor to get CIPHER

		#if defined DEBUG
		printf(" ^ P(%d)=%d == C(%d)=%d\n", i, mpz_tstbit(PLAINTEXT, i),
																				i, mpz_tstbit(CIPHER, i) );
		#endif
		i++;		j++;											//Increment counters
	}
	#if defined DEBUG
		printf("\n");
	#endif
	mpz_set(rop, CIPHER);								//Set var to generated cipher
	mpz_clear( CIPHER );
}


/*-----------------------------------------------------------------------------
 *	Generate initial m-bitmasks for the alphabet of ALPHASIZE
-----------------------------------------------------------------------------*/
mpz_t* genAlphabet( int ALPHASIZE ){
	mpz_t* B = malloc((ALPHASIZE)*sizeof( mpz_t ));
	#if defined DEBUG
	printf( "Generating 0-masks for the alphabet\n" );
	#endif

	int i=0;
	while( i < ALPHASIZE ){
		mpz_init( B[i] );
		mpz_set_ui( B[i], 0 );
		#if defined DEBUG
		printf("\tB[%d]",i);
		mpz_out_str(stdout, 2, B[i]);
		printf("\n");
		#endif
		i++;
	}
	#if defined DEBUG
	printf( "\tDone\n\n" );
	#endif
	return B;
}



/*-----------------------------------------------------------------------------
 * LFSR iteration function
 *		Calculates the next state of the LFSR by first grabbing the MSB as output
 *		value.  Then it calculates the AND of cur state and the polynomial before
 *		running an XOR on all bits that are set in the temp var to generate the
 *		feedback value.
 *
 *		Finally it left shifts the entire original state and sets the LSB to the
 *		value of the feedback polynomial.
 *
 *		The feedback value is then set
-----------------------------------------------------------------------------*/
int lfsr_iterate( struct LFSR* lfsr) {
	int			i 			= 0;										//Counter
	int			fbck 		= 0;										//XOR calculated value
	int			ret			= mpz_tstbit( lfsr->STATE, lfsr->DEGREE-1 );

	mpz_t tmp;		mpz_init( tmp );
	mpz_and(tmp, lfsr->STATE, lfsr->POLYNOMIAL);

	while( i < lfsr->DEGREE ){							//Calc feedback
		fbck = fbck + mpz_tstbit( tmp, i );
		i++;
	}
	fbck = fbck % 2;
	mpz_lshift(lfsr->STATE, lfsr->DEGREE);	//Left shift
	if( fbck == 1 )	mpz_setbit( lfsr->STATE, 0 );

	return ret;															//Return output character
}


/*-----------------------------------------------------------------------------
 * Generate LFSR and output an n-length bitsequence
 * With all arbitrary skips until first prefix is met
-----------------------------------------------------------------------------*/
void lfsrgen(mpz_t rop, int psize, int olen, mpz_t p,
						 uint_least64_t iv, int skip, mpz_t* B){
	int i;																//Counter var
	int initmatch = 0;										//Check if first prefix is found
	struct LFSR lfsr;											//Create struct variable
	#if defined DEBUG
	printf("Generating LFSR\n");
	#endif

	lfsr.DEGREE = psize;									//Set polynomial degree

	mpz_init( lfsr.POLYNOMIAL );
	mpz_set(lfsr.POLYNOMIAL, p);					//Set polynomial

	mpz_init( lfsr.STATE );
	mpz_set_ui(lfsr.STATE, iv);						//Set initial vector (seed)

	mpz_t OUTPUT;
	mpz_init( OUTPUT );
	int		tmpOUT	= 0;										//temp char holder
	char* t;
	i							= 0;										//Zero out counter
	while( i < olen ){
		tmpOUT = lfsr_iterate(&lfsr);
		if( initmatch == 0 && skip == 1) {
			if( mpz_tstbit(B[tmpOUT], 0) == 1 ){
				initmatch = 1;									//Set state to found
				if( tmpOUT == 1 )
					mpz_setbit(OUTPUT, i);				//Set output to tmpvar
				i++;														//inc counter

				#if defined DEBUG
				t = pb(B[0],m);
				printf("\tinitmatch found\t\t%d |\t0: %s", tmpOUT, t);
				mpz_out_str( stdout, 2, B[0] );
				free(t); t = pb(B[1],m);
				printf("\n\t\t\t\t\t1: %s", t);		mpz_out_str( stdout, 2, B[1] );
				printf("\n");
				free(t);
				#endif
			}
			#if defined DEBUG
			else{
				t = pb(B[0],m);
				printf("\tinitmatch not found\t%d |\t0: %s", tmpOUT, t);
				mpz_out_str( stdout, 2, B[0] );
				free(t); t = pb(B[1],m);
				printf("\n\t\t\t\t\t1: %s", t);			mpz_out_str( stdout, 2, B[1]);
				printf("\n");
				free(t);
			}
			#endif
		}
		else {
			if( tmpOUT == 1)	mpz_setbit(OUTPUT, i);
			i++;															//Next bit
		}
	}

	//Print LFSR information
	#if defined DEBUG
	printf("\n");
	printf("\tDEGREE:\t%d\n", psize);
	printf("\tLENGTH:\t%d\n", olen);
	printf("\tPOL:\t"); mpz_out_str( stdout, 2, lfsr.POLYNOMIAL );
	printf("\n\tSTT:\t");	mpz_out_str( stdout, 2, lfsr.STATE );
	printf("\n");
	printf("\tDone\n");
	#endif
	mpz_set(rop, OUTPUT);
	mpz_clear(OUTPUT);
}



/*-----------------------------------------------------------------------------
 * Creates the prefixes
-----------------------------------------------------------------------------*/
void genPrefixes( mpz_t* B, mpz_t P ){
	int	 j = 0;
	#if defined DEBUG
	printf("Generating prefixes\n");
	#endif
	mpz_t tmp;  mpz_init(tmp); mpz_set_ui( tmp, 1 );
	while( j<m ){
		int ci = mpz_tstbit(P, j);				//Char value 0/1

		#if defined DEBUG
		printf( "j=%d\tPj=%d |\t%s", j, mpz_tstbit(P,j), pb(B[ci],m) );
		mpz_out_str(stdout, 2, B[ci]);
		#endif


		mpz_ior( B[ci], B[ci], tmp );			//current value or-ed with 10^(j-1)
		mpz_lshift( tmp, m );

		#if defined DEBUG
		printf( "\n\t\t%s", pb(B[ci],m));
		mpz_out_str( stdout, 2, B[ci]);		printf( "\n" );
		#endif

		j++;															//Next pattern character
	}
	mpz_clear( tmp );
	#if defined DEBUG
	printf("\n\tDone\n\n");
	#endif
}



/*-----------------------------------------------------------------------------
 * Creates the error list of K-size
-----------------------------------------------------------------------------*/
mpz_t* genError(int K) {
	mpz_t*	R	= malloc( K*sizeof(mpz_t) );		//Allocate memory for array
	#if defined DEBUG
	printf("Gen error R[%d..%d]\n", 0, K-1);
	#endif
	int k = 0;																//Set counter
	while( k<K ){
		int i = 0;
		mpz_init( R[k] );
		while( i < k ){
			mpz_setbit( R[k], i );
			i++;
		}
		#if defined DEBUG
		printf("\tR[%d]\t= ", k);
		mpz_out_str( stdout, 2, R[i]);
		printf( "\n" );
		#endif
		k++;
	}
	#if defined DEBUG
	printf("\tDone\n");
	#endif
	return R;
}


/*-----------------------------------------------------------------------------
 * Perform search on TEXT and PREFIX
-----------------------------------------------------------------------------*/
mpz_t* arbp_search(mpz_t* B, int K) {
	mpz_t			tmp1;		mpz_init( tmp1 );		//Tmp variables
	mpz_t			tmp2;		mpz_init( tmp2 );
																				//Match for each position in text
	mpz_t*		R				= genError( K );		//Gen error-table
	mpz_t*		MATCHES = malloc( n * sizeof(mpz_t) );

	mpz_t oldR, newR;											//Create and init variables
	mpz_init( oldR );		mpz_init( newR );

	#if defined DEBUG
	printf( "Beginning search\n");				//Debug
	#endif
	uint_least64_t pos	= 0;							//Start search from char 1
	while( pos < n ){											//Search entire string
		int Ti	= mpz_tstbit(TEXT, pos);		//Grab current chars int value

		mpz_clear( oldR );	mpz_init( oldR );	//Reset variables
		mpz_clear( newR );	mpz_init( newR );

		mpz_set( oldR, R[0]);								//Init oldR to cur R[0] (R[i])

		mpz_set(tmp1, R[0]);
		mpz_lshift( tmp1, m );							//lshift
		mpz_setbit( tmp1, 0 );							//OR with 1
		mpz_and( tmp1, tmp1, B[Ti] );				//AND with B[Ti]

		mpz_set( newR, tmp1 );							//Set newR to tmp
		mpz_set(R[0], newR);								//Set R[0] to R'[i]

		uint_least64_t i	= 1;							//Calc matches with K allowed errors
		while( i < K ) {
			mpz_clear( tmp1 );	mpz_clear(tmp2);
			mpz_init(tmp1);			mpz_init(tmp2);//reset and initialise temp variables

																				//Substitute and deletion
			mpz_ior(tmp2, oldR, newR);				//tmp2 = (oldR|newR)
			mpz_lshift(tmp2, m);							//tmp2 = <tmp2> << 1
			mpz_setbit( tmp2, 0 );						//tmp2 = <tmp2> | 1
			
			#if defined INC_INSERT
																		//Insertion
			mpz_ior(tmp2, oldR, tmp2);				//tmp2 = oldR | <tmp2>
			#endif

			mpz_set(tmp1, R[i]);							//Copy value
			mpz_lshift(tmp1, m);							//tmp1 = R[i]<<1
			mpz_and(tmp1, tmp1, B[Ti]);				//tmp1 = <tmp1> & B[Ti]

			mpz_ior(tmp1, tmp1, tmp2);				//tmp1 = <tmp1> | <tmp2>

			mpz_set(newR, tmp1);							//newR = <tmp1>
			mpz_set(oldR, R[i]);							//Store R[i] for next error
			mpz_set(R[i], newR);							//R[i] == R'[i]

			i++;															//Next error
		}

		#if !defined DEBUG
		if( CSTATE == SSTATE ){
		#endif
			mpz_init( MATCHES[pos] );
			mpz_set_ui( MATCHES[pos], m );			//Init val of match at cur pos
			int j	= 0;													//Init counter
			if( mpz_tstbit(newR, m-1) == 1 ){		//Check if R-table has a match
				while( j<K ){											//Loop R-table for matches (MSB set)
					if(mpz_tstbit(R[j], m-1) == 1){	//Check if MSB set
						mpz_set_ui(MATCHES[pos], j);	//Set match to the R-level (0-K)
						j = K;												//Skip to end
					}
					j++;														//Next error value
				}
			}
		#if !defined DEBUG
		}
		#endif
		pos += 1;															//Next position in search text
	}

	#if defined DEBUG
	printf("Search done.\n");
	#endif
	mpz_clear( oldR );
	mpz_clear( newR );
	free(R);

	#if defined DEBUG
	return MATCHES;
	#else
	if( CSTATE == SSTATE )	return MATCHES;
	else										return NULL;
	#endif
}
